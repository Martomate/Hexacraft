//| mill-version: 1.0.6
//| mvnDeps:
//| - io.github.hoangmaihuy::mill-universal-packager::0.2.0

package build

import io.github.hoangmaihuy.mill.packager.archetypes.JavaAppPackagingModule
import mill.*
import mill.api.{BuildCtx, MillException}
import mill.scalalib.*
import mill.util.{JarManifest, Jvm}
import os.{Path, RelPath}

import scala.util.Properties.isMac

val HexacraftVersion = "0.15"

object Deps {
  def scalaVersion = "3.6.4"

  private object versions {
    val lwjgl = "3.3.5"
    val joml = "1.10.7"
    val zeromq = "0.6.0"
  }

  private def lwjglDependency(name: String) = {
    val os = System.getProperty("os.name").toLowerCase match {
      case os if os.contains("windows") => "windows"
      case os if os.startsWith("mac") => "macos"
      case _ => "linux"
    }
    val platform = System.getProperty("os.arch") match {
      case arch if arch.trim == "aarch64" => s"$os-arm64"
      case _ => os
    }

    Seq(
      mvn"org.lwjgl:$name:${versions.lwjgl}",
      mvn"org.lwjgl:$name:${versions.lwjgl};classifier=natives-$platform"
    )
  }

  lazy val LwjglSystem = lwjglDependency("lwjgl")
  lazy val LwjglGlfw = lwjglDependency("lwjgl-glfw")
  lazy val LwjglOpenGL = lwjglDependency("lwjgl-opengl")
  lazy val LwjglOpenAL = lwjglDependency("lwjgl-openal")
  lazy val LwjglStb = lwjglDependency("lwjgl-stb")

  lazy val Joml = mvn"org.joml:joml:${versions.joml}"
  lazy val FlowNbt = mvn"com.flowpowered:flow-nbt:1.0.0"
  lazy val ZeroMQ = mvn"org.zeromq:jeromq:${versions.zeromq}"

  lazy val MUnit = mvn"org.scalameta::munit:1.0.0"
  lazy val Mockito = mvn"org.scalatestplus::mockito-5-8:3.2.17.0"
  lazy val ArchUnit = Seq(
    mvn"com.tngtech.archunit:archunit:1.3.0",
    mvn"org.slf4j:slf4j-nop:2.0.13" // Needed for ArchUnit
  )
}

object common extends HexacraftModule {
  override def moduleDeps = super.moduleDeps ++ Seq(native)
  override def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.Joml, Deps.FlowNbt
  )

  object test extends Tests
}

object native extends HexacraftModule with RustJniModule {
  override def nativeName = "hexacraft-rs"

  override def rustSourcePaths: Seq[RelPath] = {
    Seq(
      os.rel / "src",
      os.rel / "Cargo.toml",
      os.rel / "Cargo.lock",
    )
  }

  object test extends Tests
}

object window extends HexacraftModule {
  override def moduleDeps = Seq(common)

  override def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.LwjglGlfw*
  )

  object test extends Tests
}

object audio extends HexacraftModule {
  override def moduleDeps = Seq(common, fs)

  override def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.LwjglOpenAL ++ Deps.LwjglStb*
  )

  object test extends Tests
}

object fs extends HexacraftModule {
  override def moduleDeps = Seq(common)

  object test extends Tests
}

object gpu extends HexacraftModule {
  override def moduleDeps = Seq(common, native)

  override def mvnDeps = super.mvnDeps() ++ Seq(
    Deps.LwjglOpenGL*
  )

  object test extends Tests
}

object game extends HexacraftModule {
  override def moduleDeps = Seq(common, window, fs)

  override def mvnDeps = super.mvnDeps() ++ Seq(
    Seq(Deps.Joml, Deps.ZeroMQ) ++ Deps.LwjglSystem*
  )

  object test extends Tests {
    override def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.Mockito
    )
  }
}

object client extends HexacraftModule {
  override def moduleDeps = Seq(game, audio, gpu)

  override def mvnDeps = super.mvnDeps() ++ Seq(
    Seq(Deps.Joml, Deps.ZeroMQ) ++ Deps.LwjglSystem*
  )

  object test extends Tests
}

object server extends HexacraftModule {
  override def moduleDeps = Seq(game)

  override def mvnDeps = super.mvnDeps() ++ Seq(
    Seq(Deps.Joml, Deps.ZeroMQ) ++ Deps.LwjglSystem*
  )

  object test extends Tests {
    override def moduleDeps = super.moduleDeps ++ Seq(game.test)
  }
}

object main extends HexacraftModule with JavaAppPackagingModule {
  override def moduleDeps = Seq(game, client, server)

  override def mvnDeps = super.mvnDeps() ++ Seq(
    Seq(Deps.Joml, Deps.ZeroMQ) ++ Deps.LwjglSystem*
  )

  def jdepsModules: T[String] = Task {
    val classPath = runClasspath().map(_.path).filter(os.exists).map(_.toString)
    val res = os.proc(
      Seq(
        Jvm.jdkTool("jdeps", this.javaHome().map(_.path)),
        "--multi-release", "17",
        "-R",
        "--print-module-deps",
        "--ignore-missing-deps",
        "--class-path",
      ) ++
      classPath,
    ).call()

    new String(res.out.bytes).stripSuffix("\n").stripSuffix("\r")
  }

  def jlinkAppImage: T[PathRef] = Task {
    val modules = jdepsModules()
    val outputPath = Task.dest / "runtime"

    Task.log.info(s"Creating Java runtime based on [$modules]")

    val args = Seq(
      Jvm.jdkTool("jlink", this.javaHome().map(_.path)),
      "--add-modules",
      modules,
      "--output",
      outputPath.toString,
      "--compress",
      "2",
      "--no-header-files",
      "--no-man-pages",
      "--strip-debug"
    )
    os.proc(args).call()

    PathRef(outputPath)
  }

  override def forkArgs = super.forkArgs() ++ (if (isMac) Some("-XstartOnFirstThread") else None).toSeq

  override def packageVersion = HexacraftVersion
  override def packageName = "hexacraft-" + packageVersion()
  override def executableScriptName = "hexacraft"

  def launcherJarManifest = Task {
    JarManifest.MillDefault
      .add("Main-Class" -> finalMainClass())
      .add("Class-Path" -> scriptClasspath().map(name => s"lib/$name").mkString(" "))
  }

  override def universalMappings = Task {
    val launcherJarPath = Task.dest / "launcher.jar"
    Jvm.createJar(launcherJarPath, Seq(), launcherJarManifest())

    val launcherJarMapping = PathRef(launcherJarPath) -> (os.sub / "hexacraft-launcher.jar")
    val jreMapping = jlinkAppImage() -> (os.sub / "runtime")

    super.universalMappings().filterNot(_._2.startsWith(os.sub / "bin")) ++ Seq(launcherJarMapping, jreMapping)
  }

  object test extends Tests {
    override def moduleDeps = super.moduleDeps ++ Seq(game.test, client.test)
    override def mvnDeps = super.mvnDeps() ++ Seq(
      Seq(Deps.Mockito) ++ Deps.ArchUnit*
    )
  }
}



trait HexacraftModule extends SbtModule {
  def scalaVersion = Deps.scalaVersion

  override def scalacOptions = Seq(
    "-deprecation", "-unchecked", "-feature"
  )
  override def javacOptions = Seq(
    "--release", "17"
  )

  override def compileMvnDeps = Seq(
    mvn"org.scala-lang::scala2-library-tasty-experimental:${scalaVersion()}"
  )

  override def artifactName = "hexacraft-" + super.artifactName()

  trait Tests extends SbtTests with TestModule.Munit {
    override def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.MUnit
    )
  }
}

trait RustJniModule extends JavaModule {
  /** Name used in Cargo.toml [package].name. */
  protected def nativeName: String

  /** Paths to consider when determining if a rebuild is needed */
  protected def rustSourcePaths: Seq[RelPath]

  /** Directory where the JNI headers will be stored */
  private def jniHeadersDir: Task[Path] = Task {
    val sourceHash = allSources().map(_.sig).sum
    Task.dest / s"headers-$sourceHash"
  }

  override def javacOptions = Task {
    super.javacOptions() :+ "-h" :+ jniHeadersDir().toString
  }

  override def compile = Task {
    val headersDir = jniHeadersDir()

    val res = super.compile()

    if (BuildCtx.withFilesystemCheckerDisabled(os.list(headersDir)).isEmpty) {
      throw new MillException("No JNI headers were generated. Please do a clean build.")
    }

    res
  }

  private def crateHome = moduleDir / "src" / "native"

  private def rustSources = Task.Input {
    rustSourcePaths.map(f => PathRef(crateHome / f))
  }

  override def compileResources = Task {
    super.compileResources() :+ compileNative()
  }

  override def resources = Task {
    checkJni()
    super.resources()
  }

  private val localTarget: String = {
    System.getProperty("os.name").toLowerCase match {
      case os if os.contains("windows") =>
        System.getProperty("os.arch") match {
          case arch if arch.trim == "aarch64" =>
            throw new IllegalArgumentException("Arm on Windows is not yet supported")
          case _ => "x86_64-pc-windows-msvc"
        }
      case os if os.startsWith("mac") =>
        System.getProperty("os.arch") match {
          case arch if arch.trim == "aarch64" => "aarch64-apple-darwin"
          case _ => "x86_64-apple-darwin"
        }
      case _ =>
        System.getProperty("os.arch") match {
          case arch if arch.trim == "aarch64" => "aarch64-unknown-linux-gnu"
          case _ => "x86_64-unknown-linux-gnu"
        }
    }
  }

  private def getNativeLibName(target: String, libraryName: String): String = target match {
    case _: String if target.contains("windows") => libraryName + ".dll"
    case _: String if target.contains("linux") => "lib" + libraryName + ".so"
    case _: String if target.contains("apple") => "lib" + libraryName + ".dylib"
    case _ => throw new IllegalArgumentException(s"Rust target $target not supported")
  }

  private def cargoOutputDir = Task.Source {
    crateHome / "target" / localTarget
  }

  private def compileNative = Task {
    rustSources() // recompile if the sources have changed

    os.proc("cargo", "build", "--release", "--target", localTarget).call(cwd = crateHome)

    val libFile = cargoOutputDir().path / "release" / getNativeLibName(localTarget, nativeName.replace('-', '_'))

    val libDestPath = getNativeLibEmbedPath(nativeName, localTarget)

    val resultDir = Task.dest / "embed"
    os.copy(libFile, resultDir / libDestPath, replaceExisting = true, createFolders = true)
    PathRef(resultDir)
  }

  private def getNativeLibEmbedPath(nativeName: String, target: String): os.SubPath = {
    val osName = target match {
      case t if t.contains("windows") => "windows"
      case t if t.contains("apple") => "darwin"
      case t if t.contains("linux") => "linux"
      case _ => throw new IllegalArgumentException(s"Could not extract os from target: $target")
    }
    val archName = target match {
      case t if t.contains("aarch64") => "arm64"
      case t if t.contains("x86_64") => "x86_64"
      case _ => throw new IllegalArgumentException(s"Could not extract arch from target: $target")
    }

    val targetShortName = s"$archName-$osName"
    val libFileName = getNativeLibName(target, nativeName.replace('-', '_'))

    os.sub / "native" / targetShortName / libFileName
  }

  private def checkJni: Task[Unit] = Task {
    Task.log.info("Checking JNI")
    val declarations = jniDeclarationsInHeaders().map(JniFunctionDeclaration.parseFromHeader)
    val exportedFunctionNames = jniFunctionNamesInRust()

    val result = JniCheckResult(
      extraJniExports = exportedFunctionNames.filter(name => !declarations.exists(_.mangledName == name)),
      missingJniDeclarations = declarations.filter(d => !exportedFunctionNames.contains(d.mangledName))
    )

    if (result.isMismatch) {
      result.print()
      throw new MillException("JNI mismatch (see details above)")
    }
    Task.log.info(s"Found ${declarations.size} JNI functions")
  }

  private def generatedHeaders = Task {
    compile()
    jniHeadersDir()
  }

  private def jniDeclarationsInHeaders: Task[Seq[String]] = Task {
    val headerFiles = BuildCtx.withFilesystemCheckerDisabled(
      os.list(generatedHeaders()).map(os.read.lines)
    )
    headerFiles.flatMap(JniExtractors.functionDeclarationsInHeaderFile)
  }

  private def jniFunctionNamesInRust: Task[Seq[String]] = Task {
    val p = os.proc("cargo", "expand").call(cwd = crateHome)
    JniExtractors.functionNamesInRustCode(new String(p.out.bytes))
  }
}

object JniExtractors {
  def functionDeclarationsInHeaderFile(headerFileLines: Seq[String]): Seq[String] = {
    var declarations: List[String] = Nil
    var funcStr: Option[String] = None
    for (l <- headerFileLines) {
      funcStr match {
        case Some(s) =>
          if (!l.endsWith(";")) {
            funcStr = Some(s"$s $l")
          } else {
            declarations = s"$s ${l.stripSuffix(";")}" :: declarations
            funcStr = None
          }
        case None =>
          if (l.startsWith("JNIEXPORT")) {
            funcStr = Some(l)
          }
      }
    }
    declarations.reverse
  }

  def functionNamesInRustCode(expandedSourceCode: String): Seq[String] = {
    """pub extern "system" fn (Java_[^<]*)""".r
      .findAllMatchIn(expandedSourceCode)
      .map(_.group(1))
      .toSeq
  }
}

case class JniCheckResult(extraJniExports: Seq[String], missingJniDeclarations: Seq[JniFunctionDeclaration]) {
  def isMismatch: Boolean = missingJniDeclarations.nonEmpty

  def print(): Unit = {
    if (extraJniExports.nonEmpty) {
      println()
      println(s"Extra JNI exports:\n${extraJniExports.map(name => s"    $name").mkString("\n")}")
    }

    if (missingJniDeclarations.nonEmpty) {
      println()
      println(s"Missing JNI exports:")
      for (d <- missingJniDeclarations) {
        println(s"    ${d.mangledName}")
      }

      println()
      println("Example declarations for the missing JNI exports:")

      for (d <- missingJniDeclarations) {
        println(d.declarationExample)
      }
    }
  }
}

case class JniFunctionDeclaration(returnType: String, mangledName: String, argTypes: Seq[String]) {
  def demangledName: (String, String) = {
    val namespaceLength = "_".r.findAllMatchIn(mangledName).map(_.start).toSeq.findLast { idx =>
      val rest = mangledName.substring(idx)
      !rest.startsWith("_1") && !rest.startsWith("_00024")
    }.get

    val namespace = mangledName.substring(0, namespaceLength)
      .stripPrefix("Java_")
      .replace("_1", "_")
      .replace("_00024", "$")
      .replace("_", ".")

    val function = mangledName.substring(namespaceLength + 1)
      .replace("_1", "_")

    (namespace, function)
  }

  def declarationExample: String = {
    val (namespace, function) = demangledName
    val args = argTypes.drop(1).zipWithIndex.map {
      case (t, i) => (s"p${i + 1}", rustJniArgName(t))
    }

    s"""
       |#[jni_fn("$namespace")]
       |pub fn $function<'local>(
       |    env: JNIEnv<'local>,
       |${args.map { case (n, t) => s"    $n: $t," }.mkString("\n")}
       |) -> $returnType
       |""".stripMargin
  }

  private def rustJniArgName(rawName: String): String = {
    val isRef = rawName == "jclass" || rawName.endsWith("Array")
    if (isRef) rustJniRefTypeName(rawName) else rawName
  }

  private def rustJniRefTypeName(name: String): String = {
    val capitalLetter = (name.charAt(1) - 'a' + 'A').toChar
    s"J$capitalLetter${name.substring(2)}<'local>"
  }
}

object JniFunctionDeclaration {
  def parseFromHeader(s: String): JniFunctionDeclaration = {
    val a = """JNIEXPORT (?<returnType>\w+) JNICALL (?<mangledName>\w+)\s+\((?<argsStr>.*?)\)""".r
      .findFirstMatchIn(s)
      .getOrElse(throw new RuntimeException(s"Could not parse jni function declaration:\n\t$s"))

    JniFunctionDeclaration(
      returnType = a.group("returnType"),
      mangledName = a.group("mangledName"),
      argTypes = a.group("argsStr").split(",").toSeq.map(_.strip)
    )
  }
}
